
// tinker: a place for me to scribble my experiments.

use { Vessel, MODE_RADIALOUT, MODE_STABILITYASSIST } from ksp::vessel
use { CONSOLE } from ksp::console
use { vec3 } from ksp::math
use { yield, sleep, current_time } from ksp::game

use { Common } from fx::common
use { Launch } from fx::launch
use { Ascent } from fx::ascent
use { Stager } from fx::stager
use { Orbital } from fx::orbital

use { Sequencer } from fx::sequencer

pub struct TinkerMission(common: Common) {
    common : Common = common
    vessel : Vessel = common.vessel

    stager : Stager = Stager(common)
    launch : Launch = Launch(common)
    ascent : Ascent = Ascent(common)
    orbital : Orbital = Orbital(common)

    seq : Sequencer = Sequencer()
}

impl TinkerMission {
    fn add(self, task: fn() -> bool) -> Unit = {
        self.seq.add(task)
    }
    fn run(self) -> Unit = {
        while (self.seq.step()) {

            // As of KontrolSystem 0.2.2, I see no way to
            // provide indirect execution of ASYNC methods,
            // so the call chain from the main sequencer loop
            // down to vessel.staging.next() has to be just
            // normal explicit calls.
            //
            // See issue #20 in Farsyte/to2local for my plans.

            self.stager.maybe_stage()       // staging is ASYNC
            yield()
        }
    }
}

pub fn main_flight( vessel: Vessel, target_apoapsis: float = 80000.0, heading: float = 90.0 ) -> Result<Unit, string> = {
    CONSOLE.clear()
    CONSOLE.print_line("Hello from Vessel: " + vessel.name)

    const mission = TinkerMission(Common(vessel))

    // I was hoping that "mission.launch.manual"
    // was actually of type "fn () -> bool" but alas
    // it is not.
    //
    // Trying to write
    //    mission.add(mission.launch.manual)
    // gives us the error
    //    Type fx::launch::Launch does not have a field 'manual'
    //
    // So, basically, I exchanged a one-line call into mission
    // to repeatedly call a lambda until done, with a one-line
    // call into mission to stash this on a list.
    //
    // Why? Well, in theory, this means I can manipulate the
    // mission plan after initial construction, possibly even
    // during execution.

    mission.add(fn () -> mission.launch.manual())
    mission.add(fn () -> mission.launch.liftoff())
    mission.add(fn () -> mission.ascent.gravityturn())
    mission.add(fn () -> mission.ascent.spacecoast())
    mission.add(fn () -> mission.orbital.circ_ap())

    mission.run()
    CONSOLE.print_line("mission plan complete")
}
