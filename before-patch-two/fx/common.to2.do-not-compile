use { CONSOLE } from ksp::console
use { Vessel } from ksp::vessel
use { current_time } from ksp::game
use { ThrottleManager } from ksp::control

use { Sequencer } from fx::sequencer

pub struct Common(vessel: Vessel) {
    vessel : Vessel = vessel
    sequencer : Sequencer = Sequencer(vessel)

    t0 : float = current_time() + 3600.0
    launch_azimuth: float = 90.0
    launch_altitude: float = 80000.0


    t_mgr: ThrottleManager = vessel.manage_throttle(fn(dt) -> 0.0)
    //
    // ThrottleManager allows us to specify a throttle setting from 0 to 1,
    // were 0 is all engines cut and 1 is all engines full.
    //
    // things we can do with t_mgr:
    //
    //   t_mgr.throttle = 0
    //   let curr = t_mgr.throttle
    //
    //   t_mgr.set_throttle_provider(fn (float) -> float)
    //   t_mgr.release()
    //   t_mgr.resume()
}

impl Common {
    // proxy the stage_{pending,request,cancel} API through to sequencer,
    // so that code using Common does not need to know who is actually
    // supplying the staging service.
    sync fn stage_pending(self) -> bool = { self.sequencer.stage_pending() }
    sync fn stage_request(self) -> Unit = { self.sequencer.stage_request() }
    sync fn stage_cancel(self) -> Unit = { self.sequencer.stage_cancel() }

    // Provide the "loop" entry point that takes over control of the main
    // thread to allow execution of async services. Delegate the loop
    // execution down to the sequencer.
    fn loop(self) -> Unit = {
        self.sequencer.loop() }

    sync fn met(self) -> float = {
        current_time() - self.t0 }
    
    sync fn run_at(self, eta: float, name: string, task: fn() -> float) -> Unit = {
        self.sequencer.run_at(eta, name, task) }
    
    sync fn next_seq(self, task: fn() -> float) -> Unit = {
        self.sequencer.next_seq(task) }

}