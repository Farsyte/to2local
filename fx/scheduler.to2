use { Vessel } from ksp::vessel
use { CONSOLE } from ksp::console

use { yield, sleep, current_time } from ksp::game

use { Common } from fx::common

pub struct Scheduler(vessel: Vessel) {
    vessel : Vessel = vessel

    pend_stage : bool = false

    next : Option<SchTask> = make_last_sch_task()
    name : string = ""
}

sync fn sch_insert(sch: Scheduler, node: SchTask) -> Unit = {

    if (!sch.next.defined) {
        // safety net (should never happen)
        sch.next = Some(node)
        return
    }

    if (node.when < sch.next.value.when) {
        // expected common case: inserting at the head of the list
        node.next = sch.next
        sch.next = Some(node)
        return
    }

    // insert into the list after all nodes
    // whose scheduled times are earlier or the same.
    let t1 = sch.next.value
    while (t1.next.defined) {
        let t2 = t1.next.value
        if (node.when < t2.when) {
            break
        }
        t1 = t2
    }

    node.next = t1.next
    t1.next = Some(node)
}

sync fn sch_remove(sch: Scheduler) -> Option<SchTask> = {
    const result = sch.next
    if (result.defined)
        sch.next = result.value.next
    result
}

impl Scheduler {
    sync fn stage_pending(self) -> bool = { self.pend_stage }
    sync fn stage_request(self) -> Unit = { self.pend_stage = true }
    sync fn stage_cancel(self) -> Unit = { self.pend_stage = false }

    sync fn next_when(self) -> float = { self.next.value.when }
    sync fn next_name(self) -> string = { self.next.value.name }
    sync fn next_task(self) -> fn() -> float = { self.next.value.task }

    sync fn run_at(self, eta: float, name: string, task: fn() -> float) -> Unit = {
        sch_insert(self, SchTask(eta, name, task))
    }

    sync fn step(self) -> Unit = {

        if (current_time() < self.next_when()) {
            return
        }

        const r : Option<SchTask> = sch_remove(self)
        if (!r.defined) {
            return
        }

        if (self.name != r.value.name) {
            self.name = r.value.name
        }

        let dt = r.value.task()
        if (dt > 0.0) {
            r.value.when = current_time() + dt
            sch_insert(self, r.value)
        }
    }

    fn async(self) -> Unit = {

        if (self.stage_pending()) {
            self.vessel.staging.next()
            self.stage_cancel()
        }

    }

    fn loop(self) -> Unit = {
        while (self.next_when() < NEVER) {
            self.step()
            self.async()

            // open for extension: we could decide to sleep
            // for a bit, if it is important to conserve
            // host CPU cycles. Would not want to sleep longer
            // than the ETA of the next task, and probably would
            // not want to sleep for a long time in any case.

            yield()
        }
    }
}

pub const NEVER : float = 1.0 / 0.0         // yes, Infinity.

// oddity in KontrolSystem2 0.2.2.0
// this initializer was not working:
//    next: Option<SchTask> = None()
const noSchTaskRef : Option<SchTask> = None()

struct SchTask(eta: float, name: string, task: fn() -> float) {
    next : Option<SchTask> = noSchTaskRef
    when : float = eta + current_time()
    name : string = name
    task : fn() -> float = task
}

sync fn make_last_sch_task() -> Option<SchTask> = {
    SchTask(NEVER, "never", fn() -> NEVER)
}
