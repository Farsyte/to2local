use { Vessel } from ksp::vessel
use { CONSOLE } from ksp::console

use { Scheduler } from fx::scheduler

pub struct Sequencer(vessel: Vessel) {
    scheduler: Scheduler = Scheduler(vessel)

    next: Option<Node> = no_node
    last: Option<Node> = no_node
    step: int = 0
}

struct Node(task: fn() -> float) {
    next: Option<Node> = no_node
    task: fn() -> float = task
}

// oddity in KnotrolSystem2 0.2.2.0
// this initializer was not working:
//    next: Option<Node> = None()
const no_node : Option<Node> = None()

impl Sequencer {
    sync fn stage_pending(self) -> bool = { self.scheduler.stage_pending() }
    sync fn stage_request(self) -> Unit = { self.scheduler.stage_request() }
    sync fn stage_cancel(self) -> Unit = { self.scheduler.stage_cancel() }

    sync fn run_at(self, eta: float, name: string, task: fn() -> float) -> Unit = {
        self.scheduler.run_at(eta, name, task)
    }

    sync fn next_seq(self, task: fn() -> float) -> Unit = {
        const nref : Option<Node> = Some(Node(task))
        const last : Option<Node> = self.last
        if (!self.next.defined)
            self.next = nref
        if (self.last.defined)
            self.last.value.next = nref
        self.last = nref
    }

    fn loop(self) -> Unit = {
        self.run_at(1.0, "seq", fn () -> self.step())
        self.scheduler.loop()
    }

    sync fn step(self) -> float = {
        if (self.next.defined) {
            let n = self.next.value
            let r = n.task()
            if (r <= 0.0) {
                self.next = n.next
            }
        }
        if (self.next.defined) {
            0.01
        } else {
            0.0
        }
    }
}