use { max, min, abs } from core::math

use { Vessel } from ksp::vessel
use { CONSOLE } from ksp::console

use { Scheduler } from fx::scheduler

pub struct Sequencer(vessel: Vessel) {
    scheduler: Scheduler = Scheduler(vessel)

    next: Option<Node> = no_node
    last: Option<Node> = no_node
    step: int = 0
}

struct Node(task: fn() -> float) {
    next: Option<Node> = no_node
    task: fn() -> float = task
}

// KontrolSystem2 type inferrance fails on this kind of initialization:
//    next: Option<Node> = None()

const no_node : Option<Node> = None()

impl Sequencer {
    // proxy stage_{pending,request_cancel} down to scheduler.
    sync fn stage_pending(self) -> bool = {
        self.scheduler.stage_pending() }
    sync fn stage_request(self) -> Sequencer = {
        self.scheduler.stage_request()
        self }
    sync fn stage_cancel(self) -> Sequencer = {
        self.scheduler.stage_cancel()
        self }

    sync fn run_at(self, eta: float, name: string, task: fn() -> float) -> Sequencer = {
        self.scheduler.run_at(eta, name, task)
        self }

    sync fn next_seq(self, task: fn() -> float) -> Sequencer = {
        const nref : Option<Node> = Some(Node(task))
        const last : Option<Node> = self.last
        if (!self.next.defined)
            self.next = nref
        if (self.last.defined)
            self.last.value.next = nref
        self.last = nref
        self }

    // Provide the "loop" entry point that takes over control of the main
    // thread to allow execution of async services. Delegate the loop
    // execution down to the scheduler, after establishing the scheduled
    // task that will step through the main sequence.

    fn loop(self) -> Sequencer = {
        self.run_at(0.1, "seq", fn () -> self.step())
        self.scheduler.loop()
        self }

    // service function to execute a main sequence step.
    // curently the main sequence is a singlely-linked list
    // where we discard leading entries as they indicate that
    // their task is complete.
    //
    // sequencer tasks return a floating point value. If this
    // value is positive, the same task will repeat; if it is
    // not, we move to the next task. The absolute value is how
    // long to delay.
    //
    // This function returns zero if the main sequence list is
    // actually empty. If a task returns zero, this function will
    // return a small but nonzero delay.
    //
    // Still not happy with the fact that I am using a single floating
    // point value to represent two different ideas: how long to wait
    // until the next call, and whether or not the current task is done.

    sync fn step(self) -> float = {

        if (!self.next.defined)
            return 0.0

        let n = self.next.value
        let r = n.task()
        if (r <= 0.0)
            self.next = n.next

        max(0.001, abs(r)) }
}
