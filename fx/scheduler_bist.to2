use { Vessel } from ksp::vessel
use { CONSOLE } from ksp::console

use { sleep, current_time } from ksp::game

use { Log } from fx::log

use { Bist, BistResult } from fx::bist

use { Scheduler, NEVER } from fx::scheduler

fn test_sch_init(bist: Bist, name: string, sch: Scheduler) -> BistResult = {
    bist.assert_true(name + " sch has initial NEVER task", sch.next.defined)?
    bist.assert_float(name + " never-task scheduled time", NEVER, NEVER, sch.next_when())?
    bist.assert_string(name + " never-task name", "never", sch.next_name())?

    bist.summary(name) }


fn test_sch_once(bist: Bist, name: string, sch: Scheduler) -> BistResult = {
    const t0 = current_time()
    sch.run_at(0.1, "once", fn() -> 0.0)

    bist.assert_float(name + " once-task scheduled time", t0+0.09, t0+0.11, sch.next_when())?
    bist.assert_string(name + " once-task name", "once", sch.next_name())?

    let t2 = sch.next_task()
    bist.assert_float(name + " once-task return value", 0.0, 0.0, t2())?

    sch.step()
    bist.assert_string(name + " once-task still pending", "once", sch.next_name())?

    sch.step()
    bist.assert_string(name + " once-task still pending", "once", sch.next_name())?

    sleep(0.15)

    sch.step()
    bist.assert_string(name + " once-task no longer pending", "never", sch.next_name())?

    bist.summary(name) }


fn test_sch_twice(bist: Bist, name: string, sch: Scheduler) -> BistResult = {
    const t0 = current_time()
    sch.run_at(0.10, "twice", fn() -> 0.1)

    bist.assert_float(name + " twice-task scheduled time", t0+0.09, t0+0.11, sch.next_when())?
    bist.assert_string(name + " twice-task name", "twice", sch.next_name())?

    let t2 = sch.next_task()
    bist.assert_float(name + " twice-task return value", 0.1, 0.1, t2())?

    let t2when = sch.next_when()

    sch.step()
    bist.assert_string(name + " twice-task still pending", "twice", sch.next_name())?
    bist.assert_float(name + " twice-task same schedule", t2when, t2when, sch.next_when())?

    sch.step()
    bist.assert_string(name + " twice-task still pending", "twice", sch.next_name())?
    bist.assert_float(name + " twice-task same schedule", t2when, t2when, sch.next_when())?

    sleep(0.11)
    let t3 = current_time()

    sch.step()
    bist.assert_string(name + " twice-task still pending", "twice", sch.next_name())?
    bist.assert_float(name + " twice-task second schedule", t3+0.00, t3+0.20, sch.next_when())?
    let t3when = sch.next_when()

    sch.step()
    bist.assert_string(name + " twice-task still pending", "twice", sch.next_name())?
    bist.assert_float(name + " twice-task third schedule", t3when, t3when, sch.next_when())?

    sch.next = sch.next.value.next
    bist.assert_string(name + " twice-task no longer pending", "never", sch.next_name())?

    bist.summary(name) }


fn test_sch_fizzbuzz(bist: Bist, name: string, sch: Scheduler) -> BistResult = {
    const log : Log = Log()

    sch.run_at(0.3, "fizz", fn() -> {
        if (log.lines() > 4) return 0.0
        log.add("fizz")
        0.3 })

    sch.run_at(0.5, "buzz", fn() -> {
        if (log.lines() > 4) return 0.0
        log.add("buzz")
        0.5 })

    sch.loop()

    bist.assert_string(name + " log entry 1 ", "fizz", log.pop().value)
    bist.assert_string(name + " log entry 2 ", "buzz", log.pop().value)
    bist.assert_string(name + " log entry 3 ", "fizz", log.pop().value)
    bist.assert_string(name + " log entry 4 ", "fizz", log.pop().value)
    bist.assert_string(name + " log entry 5 ", "buzz", log.pop().value)

    bist.summary(name) }


fn test_scheduler(bist: Bist, name: string, vessel: Vessel) -> BistResult = {

    // Note: bist.assert_*()? calls (with a trailing ?)
    // indicate that if that case fails, do nothing more
    // in this set of cases, returning the failure upward.

    // A fresh scheduler will report that the next pending
    // task happens NEVER, and if we call it, it returns
    // a duration that will be reached NEVER.

    const sch = Scheduler(vessel)
    test_sch_init(bist, name + " init", sch)?
    test_sch_once(bist, name + " once", sch)?
    test_sch_twice(bist, name + " twice", sch)?
    test_sch_fizzbuzz(bist, name + " fizzbuzz", sch)?

    bist.summary(name) }


pub fn scheduler_bist(bist: Bist, vessel: Vessel) -> Result<Unit, string> = {
    test_scheduler(bist, "scheduler", vessel)? }
